// Generated by gencpp from file twinny_msgs/MotorReport.msg
// DO NOT EDIT!


#ifndef TWINNY_MSGS_MESSAGE_MOTORREPORT_H
#define TWINNY_MSGS_MESSAGE_MOTORREPORT_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace twinny_msgs
{
template <class ContainerAllocator>
struct MotorReport_
{
  typedef MotorReport_<ContainerAllocator> Type;

  MotorReport_()
    : header()
    , motor_driver_mode(0)
    , left_status(0)
    , right_status(0)
    , left_NMT_status(0)
    , right_NMT_status(0)
    , left_current(0)
    , right_current(0)
    , left_peak_current(0)
    , right_peak_current(0)
    , motor_error_flag(0)
    , left_drive_bridge_status()
    , left_drive_protection_status()
    , left_system_protection_status()
    , left_drive_system_status1()
    , right_drive_bridge_status()
    , right_drive_protection_status()
    , right_system_protection_status()
    , right_drive_system_status1()
    , drive_fault_flag(false)
    , drive_fault_status(0)  {
    }
  MotorReport_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , motor_driver_mode(0)
    , left_status(0)
    , right_status(0)
    , left_NMT_status(0)
    , right_NMT_status(0)
    , left_current(0)
    , right_current(0)
    , left_peak_current(0)
    , right_peak_current(0)
    , motor_error_flag(0)
    , left_drive_bridge_status(_alloc)
    , left_drive_protection_status(_alloc)
    , left_system_protection_status(_alloc)
    , left_drive_system_status1(_alloc)
    , right_drive_bridge_status(_alloc)
    , right_drive_protection_status(_alloc)
    , right_system_protection_status(_alloc)
    , right_drive_system_status1(_alloc)
    , drive_fault_flag(false)
    , drive_fault_status(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint16_t _motor_driver_mode_type;
  _motor_driver_mode_type motor_driver_mode;

   typedef uint16_t _left_status_type;
  _left_status_type left_status;

   typedef uint16_t _right_status_type;
  _right_status_type right_status;

   typedef uint8_t _left_NMT_status_type;
  _left_NMT_status_type left_NMT_status;

   typedef uint8_t _right_NMT_status_type;
  _right_NMT_status_type right_NMT_status;

   typedef int16_t _left_current_type;
  _left_current_type left_current;

   typedef int16_t _right_current_type;
  _right_current_type right_current;

   typedef int16_t _left_peak_current_type;
  _left_peak_current_type left_peak_current;

   typedef int16_t _right_peak_current_type;
  _right_peak_current_type right_peak_current;

   typedef uint8_t _motor_error_flag_type;
  _motor_error_flag_type motor_error_flag;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _left_drive_bridge_status_type;
  _left_drive_bridge_status_type left_drive_bridge_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _left_drive_protection_status_type;
  _left_drive_protection_status_type left_drive_protection_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _left_system_protection_status_type;
  _left_system_protection_status_type left_system_protection_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _left_drive_system_status1_type;
  _left_drive_system_status1_type left_drive_system_status1;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _right_drive_bridge_status_type;
  _right_drive_bridge_status_type right_drive_bridge_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _right_drive_protection_status_type;
  _right_drive_protection_status_type right_drive_protection_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _right_system_protection_status_type;
  _right_system_protection_status_type right_system_protection_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _right_drive_system_status1_type;
  _right_drive_system_status1_type right_drive_system_status1;

   typedef uint8_t _drive_fault_flag_type;
  _drive_fault_flag_type drive_fault_flag;

   typedef uint16_t _drive_fault_status_type;
  _drive_fault_status_type drive_fault_status;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(current_factor)
  #undef current_factor
#endif
#if defined(_WIN32) && defined(ALARM)
  #undef ALARM
#endif
#if defined(_WIN32) && defined(CTRL_FAIL)
  #undef CTRL_FAIL
#endif
#if defined(_WIN32) && defined(OVER_VOLT)
  #undef OVER_VOLT
#endif
#if defined(_WIN32) && defined(OVER_TEMP)
  #undef OVER_TEMP
#endif
#if defined(_WIN32) && defined(OVER_LOAD)
  #undef OVER_LOAD
#endif
#if defined(_WIN32) && defined(HALL_FAIL)
  #undef HALL_FAIL
#endif
#if defined(_WIN32) && defined(INV_VEL)
  #undef INV_VEL
#endif
#if defined(_WIN32) && defined(STALL)
  #undef STALL
#endif
#if defined(_WIN32) && defined(DRIVE_INTERNAL_ERROR)
  #undef DRIVE_INTERNAL_ERROR
#endif
#if defined(_WIN32) && defined(SHORT_CIRCUIT)
  #undef SHORT_CIRCUIT
#endif
#if defined(_WIN32) && defined(CURRENT_OVERSHOOT)
  #undef CURRENT_OVERSHOOT
#endif
#if defined(_WIN32) && defined(UNDER_VOLTAGE)
  #undef UNDER_VOLTAGE
#endif
#if defined(_WIN32) && defined(OVER_VOLTAGE)
  #undef OVER_VOLTAGE
#endif
#if defined(_WIN32) && defined(DRIVE_OVER_TEMPERATURE)
  #undef DRIVE_OVER_TEMPERATURE
#endif
#if defined(_WIN32) && defined(INVALID_HALL_STATE)
  #undef INVALID_HALL_STATE
#endif
#if defined(_WIN32) && defined(MOTOR_OVER_TEMPERATURE)
  #undef MOTOR_OVER_TEMPERATURE
#endif
#if defined(_WIN32) && defined(PHASE_DECTION_FAULT)
  #undef PHASE_DECTION_FAULT
#endif
#if defined(_WIN32) && defined(FEEDBACK_SENSOR_ERROR)
  #undef FEEDBACK_SENSOR_ERROR
#endif
#if defined(_WIN32) && defined(NODE_GUARDING)
  #undef NODE_GUARDING
#endif

  enum {
    ALARM = 0u,
    CTRL_FAIL = 1u,
    OVER_VOLT = 2u,
    OVER_TEMP = 3u,
    OVER_LOAD = 4u,
    HALL_FAIL = 5u,
    INV_VEL = 6u,
    STALL = 7u,
    DRIVE_INTERNAL_ERROR = 1u,
    SHORT_CIRCUIT = 2u,
    CURRENT_OVERSHOOT = 4u,
    UNDER_VOLTAGE = 8u,
    OVER_VOLTAGE = 16u,
    DRIVE_OVER_TEMPERATURE = 32u,
    INVALID_HALL_STATE = 64u,
    MOTOR_OVER_TEMPERATURE = 128u,
    PHASE_DECTION_FAULT = 256u,
    FEEDBACK_SENSOR_ERROR = 512u,
    NODE_GUARDING = 1024u,
  };

  static const double current_factor;

  typedef boost::shared_ptr< ::twinny_msgs::MotorReport_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::twinny_msgs::MotorReport_<ContainerAllocator> const> ConstPtr;

}; // struct MotorReport_

typedef ::twinny_msgs::MotorReport_<std::allocator<void> > MotorReport;

typedef boost::shared_ptr< ::twinny_msgs::MotorReport > MotorReportPtr;
typedef boost::shared_ptr< ::twinny_msgs::MotorReport const> MotorReportConstPtr;

// constants requiring out of line definition

   
   template<typename ContainerAllocator> const double
      MotorReport_<ContainerAllocator>::current_factor =
        
          0.1
        
        ;
   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::twinny_msgs::MotorReport_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::twinny_msgs::MotorReport_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::twinny_msgs::MotorReport_<ContainerAllocator1> & lhs, const ::twinny_msgs::MotorReport_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.motor_driver_mode == rhs.motor_driver_mode &&
    lhs.left_status == rhs.left_status &&
    lhs.right_status == rhs.right_status &&
    lhs.left_NMT_status == rhs.left_NMT_status &&
    lhs.right_NMT_status == rhs.right_NMT_status &&
    lhs.left_current == rhs.left_current &&
    lhs.right_current == rhs.right_current &&
    lhs.left_peak_current == rhs.left_peak_current &&
    lhs.right_peak_current == rhs.right_peak_current &&
    lhs.motor_error_flag == rhs.motor_error_flag &&
    lhs.left_drive_bridge_status == rhs.left_drive_bridge_status &&
    lhs.left_drive_protection_status == rhs.left_drive_protection_status &&
    lhs.left_system_protection_status == rhs.left_system_protection_status &&
    lhs.left_drive_system_status1 == rhs.left_drive_system_status1 &&
    lhs.right_drive_bridge_status == rhs.right_drive_bridge_status &&
    lhs.right_drive_protection_status == rhs.right_drive_protection_status &&
    lhs.right_system_protection_status == rhs.right_system_protection_status &&
    lhs.right_drive_system_status1 == rhs.right_drive_system_status1 &&
    lhs.drive_fault_flag == rhs.drive_fault_flag &&
    lhs.drive_fault_status == rhs.drive_fault_status;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::twinny_msgs::MotorReport_<ContainerAllocator1> & lhs, const ::twinny_msgs::MotorReport_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace twinny_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::twinny_msgs::MotorReport_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::twinny_msgs::MotorReport_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::twinny_msgs::MotorReport_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::twinny_msgs::MotorReport_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::twinny_msgs::MotorReport_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::twinny_msgs::MotorReport_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::twinny_msgs::MotorReport_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fe02ce809fad1b492fd33e316a77ebd5";
  }

  static const char* value(const ::twinny_msgs::MotorReport_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfe02ce809fad1b49ULL;
  static const uint64_t static_value2 = 0x2fd33e316a77ebd5ULL;
};

template<class ContainerAllocator>
struct DataType< ::twinny_msgs::MotorReport_<ContainerAllocator> >
{
  static const char* value()
  {
    return "twinny_msgs/MotorReport";
  }

  static const char* value(const ::twinny_msgs::MotorReport_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::twinny_msgs::MotorReport_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"float64 current_factor=0.1\n"
"\n"
"uint8 ALARM=0\n"
"uint8 CTRL_FAIL=1\n"
"uint8 OVER_VOLT=2\n"
"uint8 OVER_TEMP=3\n"
"uint8 OVER_LOAD=4\n"
"uint8 HALL_FAIL=5\n"
"uint8 INV_VEL=6\n"
"uint8 STALL=7\n"
"\n"
"uint16 motor_driver_mode\n"
"\n"
"uint16 left_status\n"
"uint16 right_status\n"
"uint8 left_NMT_status\n"
"uint8 right_NMT_status\n"
"\n"
"int16 left_current\n"
"int16 right_current\n"
"int16 left_peak_current\n"
"int16 right_peak_current\n"
"\n"
"uint8 motor_error_flag\n"
"\n"
"string left_drive_bridge_status\n"
"string left_drive_protection_status\n"
"string left_system_protection_status\n"
"string left_drive_system_status1\n"
"\n"
"string right_drive_bridge_status\n"
"string right_drive_protection_status\n"
"string right_system_protection_status\n"
"string right_drive_system_status1\n"
"\n"
"bool drive_fault_flag\n"
"\n"
"uint16 DRIVE_INTERNAL_ERROR = 1\n"
"uint16 SHORT_CIRCUIT = 2\n"
"uint16 CURRENT_OVERSHOOT = 4\n"
"uint16 UNDER_VOLTAGE = 8\n"
"uint16 OVER_VOLTAGE = 16\n"
"uint16 DRIVE_OVER_TEMPERATURE = 32\n"
"uint16 INVALID_HALL_STATE = 64\n"
"uint16 MOTOR_OVER_TEMPERATURE = 128\n"
"uint16 PHASE_DECTION_FAULT = 256\n"
"uint16 FEEDBACK_SENSOR_ERROR = 512\n"
"uint16 NODE_GUARDING = 1024\n"
"\n"
"uint16 drive_fault_status\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::twinny_msgs::MotorReport_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::twinny_msgs::MotorReport_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.motor_driver_mode);
      stream.next(m.left_status);
      stream.next(m.right_status);
      stream.next(m.left_NMT_status);
      stream.next(m.right_NMT_status);
      stream.next(m.left_current);
      stream.next(m.right_current);
      stream.next(m.left_peak_current);
      stream.next(m.right_peak_current);
      stream.next(m.motor_error_flag);
      stream.next(m.left_drive_bridge_status);
      stream.next(m.left_drive_protection_status);
      stream.next(m.left_system_protection_status);
      stream.next(m.left_drive_system_status1);
      stream.next(m.right_drive_bridge_status);
      stream.next(m.right_drive_protection_status);
      stream.next(m.right_system_protection_status);
      stream.next(m.right_drive_system_status1);
      stream.next(m.drive_fault_flag);
      stream.next(m.drive_fault_status);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct MotorReport_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::twinny_msgs::MotorReport_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::twinny_msgs::MotorReport_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "motor_driver_mode: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.motor_driver_mode);
    s << indent << "left_status: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.left_status);
    s << indent << "right_status: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.right_status);
    s << indent << "left_NMT_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.left_NMT_status);
    s << indent << "right_NMT_status: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.right_NMT_status);
    s << indent << "left_current: ";
    Printer<int16_t>::stream(s, indent + "  ", v.left_current);
    s << indent << "right_current: ";
    Printer<int16_t>::stream(s, indent + "  ", v.right_current);
    s << indent << "left_peak_current: ";
    Printer<int16_t>::stream(s, indent + "  ", v.left_peak_current);
    s << indent << "right_peak_current: ";
    Printer<int16_t>::stream(s, indent + "  ", v.right_peak_current);
    s << indent << "motor_error_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.motor_error_flag);
    s << indent << "left_drive_bridge_status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.left_drive_bridge_status);
    s << indent << "left_drive_protection_status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.left_drive_protection_status);
    s << indent << "left_system_protection_status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.left_system_protection_status);
    s << indent << "left_drive_system_status1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.left_drive_system_status1);
    s << indent << "right_drive_bridge_status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.right_drive_bridge_status);
    s << indent << "right_drive_protection_status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.right_drive_protection_status);
    s << indent << "right_system_protection_status: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.right_system_protection_status);
    s << indent << "right_drive_system_status1: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.right_drive_system_status1);
    s << indent << "drive_fault_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.drive_fault_flag);
    s << indent << "drive_fault_status: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.drive_fault_status);
  }
};

} // namespace message_operations
} // namespace ros

#endif // TWINNY_MSGS_MESSAGE_MOTORREPORT_H
